<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Data Logger</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: monospace; background: #1e1e1e; color: #d4d4d4; padding: 20px; height: 100vh; display: flex; flex-direction: column; }
  h1 { margin-bottom: 12px; font-size: 1.4em; }
  .controls { display: flex; gap: 8px; margin-bottom: 12px; }
  .controls button {
    padding: 8px 20px; border: none; border-radius: 4px; cursor: pointer;
    font-family: monospace; font-size: 14px; font-weight: bold;
  }
  #btnStart { background: #4caf50; color: #fff; }
  #btnStop { background: #f44336; color: #fff; }
  #btnClear { background: #ff9800; color: #fff; }
  #btnSave { background: #2196f3; color: #fff; }
  .controls button:disabled { opacity: 0.4; cursor: default; }
  #status { margin-bottom: 8px; font-size: 13px; }
</style>
</head>
<body>
<h1>Data Logger</h1>
<div id="status">Status: Idle | Entries: 0</div>
<div class="controls">
  <button id="btnStart">Start</button>
  <button id="btnStop" disabled>Stop</button>
  <button id="btnClear">Clear</button>
  <button id="btnSave">Save</button>
</div>
<script src="LogCompressor.js"></script>
<script>
(function() {
  const statusEl = document.getElementById('status');
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnClear = document.getElementById('btnClear');
  const btnSave = document.getElementById('btnSave');

  let ws = null;
  let logging = false;
  let startTime = null;
  let compressed = null;
  let entryCount = 0;
  let lastLoggedJson = null;      // full JSON string of last logged message
  let lastNonTimeJson = null;     // JSON string with RunningTime stripped
  let lastTimeLogAt = 0;          // performance.now() of last time-only log

  function updateStatus(msg) {
    const state = logging ? 'Logging' : (ws && ws.readyState === WebSocket.OPEN ? 'Connected' : 'Disconnected');
    statusEl.textContent = `Status: ${state}${msg ? ' â€” ' + msg : ''} | Entries: ${entryCount}`;
  }

  function connectWebSocket() {
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
    ws = new WebSocket('ws://localhost:8080');
    ws.onopen = () => { updateStatus('WebSocket open'); };
    ws.onclose = () => { updateStatus('WebSocket closed'); setTimeout(connectWebSocket, 3000); };
    ws.onerror = () => { updateStatus('WebSocket error'); };
    ws.onmessage = (evt) => {
      if (!logging) return;
      let payload;
      try { payload = JSON.parse(evt.data); } catch { payload = evt.data; }

      // Build a copy without RunningTime for comparison
      const fullJson = JSON.stringify(payload);
      let nonTimeCopy = payload;
      if (payload && payload.swimming) {
        nonTimeCopy = JSON.parse(fullJson);
        delete nonTimeCopy.swimming.RunningTime;
      }
      const nonTimeJson = JSON.stringify(nonTimeCopy);

      // Determine if we should log this message
      const nonTimeChanged = nonTimeJson !== lastNonTimeJson;
      const now = performance.now();
      const timeOnlyChange = !nonTimeChanged && fullJson !== lastLoggedJson;
      const enoughTimePassed = (now - lastTimeLogAt) >= 2000;

      if (!nonTimeChanged && !timeOnlyChange) return; // exact duplicate
      if (timeOnlyChange && !enoughTimePassed) return; // throttle time-only updates

      const elapsed = Math.round((now - startTime)) / 1000;
      compressed = LogCompressor.addEntry(compressed, elapsed, payload);
      entryCount++;
      updateStatus();

      lastLoggedJson = fullJson;
      lastNonTimeJson = nonTimeJson;
      if (timeOnlyChange) lastTimeLogAt = now;
      if (nonTimeChanged) lastTimeLogAt = now;
    };
  }

  btnStart.addEventListener('click', () => {
    if (logging) return;
    logging = true;
    if (startTime === null) startTime = performance.now();
    btnStart.disabled = true;
    btnStop.disabled = false;
    connectWebSocket();
    updateStatus();
  });

  btnStop.addEventListener('click', () => {
    if (!logging) return;
    logging = false;
    btnStart.disabled = false;
    btnStop.disabled = true;
    updateStatus();
  });

  btnClear.addEventListener('click', () => {
    logging = false;
    compressed = null;
    entryCount = 0;
    startTime = null;
    lastLoggedJson = null;
    lastNonTimeJson = null;
    lastTimeLogAt = 0;
    btnStart.disabled = false;
    btnStop.disabled = true;
    updateStatus();
  });

  btnSave.addEventListener('click', () => {
    const final = LogCompressor.applyDict(compressed);
    const text = LogCompressor.stringify(final);
    const blob = new Blob([text], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'log_' + new Date().toISOString().replace(/[:.]/g, '-') + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  connectWebSocket();
})();
</script>
</body>
</html>
