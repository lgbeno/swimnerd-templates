<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timer Overlay</title>

    <!-- THEME: Change this line to switch themes -->
    <link href="themes/mario-theme.css" rel="stylesheet">
    <!-- Alternative: <link href="themes/default-theme.css" rel="stylesheet"> -->

    <style>
        /* ==================== */
        /* STRUCTURAL CSS ONLY */
        /* (Layout, positioning) */
        /* ==================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            height: 100vh;
            overflow: hidden;
        }

        .timer-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            overflow: visible;
        }

        .timer-content {
            padding: 15px 30px 15px 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: scale(0);
            opacity: 0;
            position: relative;
        }

        .timer-label {
            margin-right: 15px;
            margin-left: 5px;
            text-transform: uppercase;
        }

        .running-time {
            font-variant-numeric: tabular-nums;
            letter-spacing: 2px;
        }

        /* Placeholder styling */
        .placeholder-content {
            padding: 15px 30px 15px 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            opacity: 0.6;
        }

        .placeholder-content.hidden {
            display: none;
        }

        .placeholder-text {
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div class="timer-container">
        <!-- Placeholder shown until first data received -->
        <div class="placeholder-content timer-content visible" id="placeholder">
            <span class="placeholder-text">Waiting for data...</span>
        </div>

        <div class="timer-content" id="timerContent">
            <div class="clock-hand" id="clockHand"></div>
            <span class="timer-label">TIME</span>
            <span class="running-time" id="runningTime"></span>
        </div>
    </div>

    <script id="swimmingScript">
        let timerVisible = false;
        let firstMessageReceived = false;
        let lastScoreboardState = 0;
        let raceStartTime = 0;
        const FINAL_TIME_GUARD_MS = 10000;

        const channel = new BroadcastChannel('swimnerd-scoreboard');
        channel.onmessage = function(e) {
            processTimerData(e.data);
        };

        let client = null;
        function connectWebSocket() {
            try {
                client = new WebSocket("ws://localhost:8080/");
                client.onerror = () => console.log('WebSocket Connection Error');
                client.onopen = () => console.log('WebSocket Client Connected');
                client.onclose = () => {
                    console.log('WebSocket Client Closed');
                    setTimeout(connectWebSocket, 3000);
                };
                client.onmessage = (e) => processTimerData(JSON.parse(e.data));
            } catch (e) {
                console.log('WebSocket not available');
            }
        }
        connectWebSocket();

        function checkAllActiveFinished(laneAthleteTeam) {
            let activeCount = 0;
            let finishedCount = 0;
            for (let i = 0; i < 8; i++) {
                const lane = laneAthleteTeam[i];
                if (lane.LaneNumber && lane.LaneNumber.trim() !== "") {
                    activeCount++;
                    if (lane.Place && lane.Place.trim() !== "" && lane.Place.trim() !== " ") {
                        finishedCount++;
                    }
                }
            }
            return activeCount > 0 && finishedCount === activeCount;
        }

        function processTimerData(jsonData) {
            // Hide placeholder on first message
            if (!firstMessageReceived) {
                firstMessageReceived = true;
                document.getElementById('placeholder').classList.add('hidden');
            }

            const timerContent = document.getElementById('timerContent');
            const runningTime = document.getElementById('runningTime');
            const clockHand = document.getElementById('clockHand');
            const time = jsonData.swimming.RunningTime;
            const scoreboardState = jsonData.swimming.ScoreboardCurrentState || 0;

            // Track race start for guard period
            if (scoreboardState === 3 && lastScoreboardState !== 3) {
                raceStartTime = Date.now();
            }
            lastScoreboardState = scoreboardState;

            const pastGuard = (Date.now() - raceStartTime) >= FINAL_TIME_GUARD_MS;
            const allFinished = pastGuard && checkAllActiveFinished(jsonData.swimming.LaneAthleteTeam);

            // Timer visible only when race is actively running (state 3 and not all finished)
            if (scoreboardState === 3 && !allFinished) {
                runningTime.textContent = time;

                // Update clock hand rotation
                const parts = time.split(':');
                if (parts.length === 2) {
                    const secs = parseFloat(parts[1]) || 0;
                    clockHand.style.setProperty('--seconds', secs % 60);
                }

                if (!timerVisible) {
                    timerContent.classList.remove('hiding');
                    timerContent.classList.add('visible');
                    timerVisible = true;
                }
            } else {
                if (timerVisible) {
                    timerContent.classList.remove('visible');
                    timerContent.classList.add('hiding');
                    timerVisible = false;
                    setTimeout(() => {
                        if (!timerVisible) runningTime.textContent = '';
                    }, 300);
                }
            }
        }
    </script>
</body>
</html>
